%%%%%%%%%%%%%
% TODO
%%%%%%%

\section{Introduction}
%Talk about confidentiality and why you want to write confidentiality specs.

Writing a confidentiality specification is generally harder that writing a correctness specification. To demonstrate the possible hardships of writing a specification that can prevent malicious implementations, lets look at a specification for create() operation from our confidential file system ConFs. create() takes an owner and creates an empty file owned by the provided owner. Upon successful completion, it returns the inode number that points to that file. A natural correctness specification for its return value could be "create() returns the index of the previously unused inode that now corresponds to the newly created file." If we were only interested in functional correctness, this could be an acceptable specification. However there is a big confidentiality problem  associated with this specification. create() is allowed to return any inode number as long as it was unused at the time of the call. A malicious implementation can take advantage of this nondeterminism in the specification to pick the returned inode number to leak confidential data.

This problem, and others of the same nature, could be solved by writing a fully deterministic specification for create() that exactly pinpoints what it should return and what the file system state should be after its completion. However, such a specification would be overly verbose. This verbosity would obscure the important parts of the specification, making it hard to read and comprehend, essentially defeating one of the key purposes of a specification. Therefore, a good confidentiality specification should address such vulnerabilities in its scope but also should be clear and concise so it can be read, understood and reviewed by humans. Finding the right balance between these conflicting requirements is what makes writing a confidentiality specification hard.

Our proposed solution to above problems is ConFrm, a framework for implementing and proving the confidentiality of storage systems in a modular fashion. ConFrm facilitates a noninterference definition with better guarantees for nondeterministic behavior, and provides the required tools and necessary conditions for safety preserving abstractions. These two components of ConFrm enable us to overcome the limitations of previous works and provide a simple yet powerful tool for implementing safe storage systems. 

To test the capabilities of ConFrm, we implemented ConFS, a confidential file system that is crash resistant via checksum logging, transactional operations and coarse-grained discretionary access control. 

Both ConFrm and ConFS are implemented in Coq. Proofs are fully machine checked to ensure their correctness.

