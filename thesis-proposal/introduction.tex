%%%%%%%%%%%%%
% TODO
%%%%%%%

\section{Introduction}
As the computation and storage paradigms shifting towards cloud, safety of computation and data is becoming increasingly important.
Users expect their data stored in such systems to stay secret against the malicious third parties. 
Precise description of how such a system should behave to ensure confidentiality of the stored data is called a confidentiality specification. A confidentiality specification of a system both forces a system to maintain certain properties, and informs users about the safety guarantees a system provides.

Writing a confidentiality specification is generally harder that writing a correctness specification. To demonstrate the possible hardships of writing a specification that can prevent malicious implementations, let's look at a specification for the create() operation from our confidential file system ConFs. create() takes an owner and creates an empty file owned by the provided owner. Upon successful completion, it returns the inode number that points to that file. A natural correctness specification for its return value could be ``create() returns the index of the previously unused inode that now corresponds to the newly created file.'' If we were only interested in functional correctness, this could be an acceptable specification. However, there is a big confidentiality problem  associated with this specification. create() is allowed to return any inode number as long as it was unused at the time of the call. A malicious implementation can take advantage of this nondeterminism in the specification to pick the returned inode number to leak confidential data (e.g. last byte of the return value being equal to the first byte of a block that belongs to another user).

This problem, and others of the same nature, could be solved by writing a fully deterministic specification for create() that exactly pinpoints what it should return and what the file-system state should be after its completion. However, such a specification would be overly verbose. This verbosity would obscure the important parts of the specification, making it hard to read and comprehend, essentially defeating one of the key purposes of a specification. Therefore, a good confidentiality specification should address such vulnerabilities in its scope but also should be clear and concise so it can be read, understood and reviewed by humans. Finding the right balance between these conflicting requirements is what makes writing a confidentiality specification hard.

Our proposed solution to the above problems is ConFrm, a framework for implementing and proving the confidentiality of storage systems in a modular fashion. ConFrm provides a noninterference definition with better guarantees for nondeterministic behavior, and it provides the required tools and necessary conditions for safety-preserving abstractions. These two components of ConFrm enable us to overcome the limitations of previous works and provide a simple yet powerful tool for implementing safe storage systems. 

To test the capabilities of ConFrm, we implemented ConFS, a confidential file system that is crash-resistant via checksum logging, transactional operations and coarse-grained discretionary access control. 

Both ConFrm and ConFS are implemented in Coq. Proofs are fully machine-checked to ensure their correctness.

