\section{Definitions}

We use $a$ and $i$ to denote abstraction and implementation states respectively, and use $s$ when distinction is irrelevant.
$s =p\Rightarrow (s', v)$ denotes the execution of program $p$ from state $s$ that results in state $s'$ and returns $v$. $\approx$ is used to represent an equivalence relation between two abstract states. $R$ denotes a refinement relation between abstraction and its implementation. $R(p)$ represents the refining implementation program, and $R(\approx)$ represents derived equivalence relation between two implementation states. $R(\approx)$ is defined as 
$$
i_1\ R(\approx)\ i_2 := \exists\ a_1\ a_2,\ i_1\ R\ a_1\ \wedge\ i_2\ R\ a_2\ \wedge\ a_1 \approx a_2
$$

Standard definitions we use for noninterference, termination sensitivity and simulation are given below for the sake of completeness.
\subsubsection*{Noninterference}

$\forall\ s_1\ s_2\ s_1'\ v,$\\
$s_1\approx s_2 \rightarrow$\\
$s_1 =p_1\Rightarrow (s_1', v) \rightarrow$\\
$\exists s_2',\ s_2 =p_2\Rightarrow (s_2', v)\ \wedge\ s_1'\approx s_2'.$

\subsubsection*{Termination Sensitivity}

$\forall\ s_1\ s_2\ s_1'\ v,$\\
$s_1\approx s_2 \rightarrow$\\
$s_1 =p_1\Rightarrow (s_1', v) \rightarrow$\\
$\exists s_2'\ v',\ s_2 =p_2\Rightarrow (s_2', v').$

\subsubsection*{Simulation}

$\forall\ i\ i'\ a\ v,$\\
$i\ R\ a \rightarrow$\\
$i =R(p)\Rightarrow (i', v) \rightarrow$\\
$\exists a',\ a =p\Rightarrow (a', v)\ \wedge\ i'\ R\ a'.$

