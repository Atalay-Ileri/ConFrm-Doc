\subsection*{Problems and Motivation}
\paragraph{Unsafety from Probability}
We are trying to tackle two problems in this work. First issue is the interaction between nondeterminism and noninterference. More specifically, standard noninterference definition fail to address leakages that resulted from different frequencies of possible execution traces of the same program. A simple example of this weakness can be seen below: 


\begin{lstlisting}
if (random_bit() = = 1)
  return secret_bit
else
  return random_bit()
\end{lstlisting}

This code leaks the secret bit 50\% of the time and outputs a random bit 50\% of the time. It is also important to note that it can output 0 or 1 independent of the secret value. This way, any (state, return) pair represents a successful execution. 

//Write a transition here or move NI definition to somewhere else

% \paragraph{Nondeterministic Noninterference}

\begin{lstlisting}
forall p s1 s2 s1r v,
  equivalent s1 s2 ->
  exec s1 p s1r v ->
	
  exists s2r,
    exec s2 p s2r v /\
    equivalent s1r s2r.
\end{lstlisting} 

Let's say that two states are equivalent if they are the same for their non-secret parts. Since any pair of state an return value is a valid execution, you can find another execution from a related state. This makes it satisfy NI definition.

\begin{comment}
Here is a table for all possible ways an execution of above function could go:\\

\begin{tabular}{| c | c | c | c | c |}
	\hline
	 & Secret Bit & First Random Bit & Output & Noninterfering Execution \\
	\hline
	a &	0 & 0 & 0 & d \\
	\hline
	b &	0 & 0 & 1 & e \\
	\hline
	c &	0 & 1 & 0 & d \\
	\hline
	\hline
	d &	1 & 0 & 0 & a \\
	\hline
	e &	1 & 0 & 1 & b \\
	\hline
	f &	1 & 1 & 1 & b \\
	\hline
\end{tabular}\\

For each state and an execution from it, there is a corresponding execution from each related state with same return value. If a related state has same secret bit value, first execution is also the second execution. If a related state has opposite secret bit value, then corresponding execution is given in the above table. This demonstrates how given code snippet satisfies NI.
\end{comment}

Although the above program satisfies the NI definition, the secret bit can be determined via the observed frequency of repeated calls. When we look at the frequencies of output values, we can see that they correlate with the value of the secret bit.\\

\begin{tabular}{| c | c | c |}
	\hline
	Secret bit & Output 0 \% & Output 1 \% \\
	\hline
	0 &	75\% & 25\% \\
	\hline
	1 &	25\% & 75\% \\
	\hline
\end{tabular}\\

//write a conclusion before moving to the next problem.

% == motivation

% frequency -> probability

% "unsafe primitives": what is a safe primitive? seems to relate to
% disksec's approach of not allowing any operations on data?

% is data dedup a case where you can prove a meaningful non-interference
% property? you say "safe dedup": what does that look like?

% don't understand the `write_to_txn` example

% better example for unsafe primitives

% some example for scalability

% == approach

% quantification of ND: looks good to me

% abstraction: what's different from many other kinds of abstraction,
% like certikos?

% NI transfer: is this a metatheory contribution, or does this impact how
% the developer uses the system? 



\paragraph{Unsafe Data Handling}
The second problem observed involves handling the data in a potentially unsafe way. Many storage systems process the data provided to them before storing it. A potentially malicious developer can take advantage of this capability to leak information.

A classic example of this phenomenon is branching on confidential data. If not done carefully, it can result in leakage of confidential data. This does not mean that branching on confidential data should be avoided at all costs.

Data deduplication in a storage system in a good example to demonstrate this effect. For this example, we will treat data contents secret but metadata public. Therefore a user learning extra space savings is fine.

Deduplication requires branching on confidential data, which can be abused if not handled carefully. Consider following obviously unsafe implementation:

\begin{lstlisting}
write_to_txn(v)
  if (v is in txn)
    return false
  else
    add_to_txn(v)
    return true
\end{lstlisting}

This implementation allows an adversary to query the contents of the transaction. 
A simple solution that can be considered to solve this problem is prohibiting branching control flow based on confidential data.This can be achieved by using a deep embedded language that doesn't have an operation to compare secret data or treating secret data as an abstract object that can't be compared. Such approaches has the advantage 
that any program written in such a language is noninterfering by construction. 

It is quite a strong property but also a restrictive one which eliminates many possible efficient implementations.

However, It is possible to implement a safe deduplicator. One way would be performing the process after the transaction is finalized but before committing it. Such a deferred deduplication will still branch on confidential data but without revealing it.

An ideal solution would prohibit unsafe implementations while allowing the safe ones with as little constraint as possible.  


\paragraph{Modularity and Compositionality}
We aim to solve above problems while providing modularity and compositionality. Any technique that will be used in large scale projects is required to support modularity, compositionality, expressive power, and interoperability with other techniques. Provided solution should not constrain developers to a certain proof technique for proving safety, as well as allow them to model systems they are working on to the desired level of detail. 


% FK: I don't understand what scalability is from the above
% paragraph. Could you give a concrete example as you did for the other
% two challenges?

% NZ: scalability -> composability
% Give composability example.