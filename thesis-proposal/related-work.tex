\section{Related Work}

ConFrm and ConFs builds on a diverse body of prior work. We will explain these works throughout this chapter. 

\paragraph{Relatively deterministic noninterference.} There is a significant work on formalizing noninterference properties [19, 25, 26, 29, 30, 32, disksec]. ConFrm's relatively deterministic noninterference builds on top of this existing work. Our definition is different from previous body of work by how it treats nondeterminism in its formalism. RDNI takes a more fine grained approach on relating nondeterministic executions.

%rewrite this
\paragraph{Machine-checked security in systems.} 
Several prior
projects have proven security (and, specifically, confidentiality) properties about their system implementations:
seL4 [23, 26], CertiKOS [15], Ironclad [20] and DiskSec[??]. For
seL4 and CertiKOS, the theorems prove complete isolation: CertiKOS requires disabling IPC to prove its security
theorems, and seL4’s security theorem requires disjoint
sets of capabilities. In the context of a file system, complete isolation is not possible: one of the main goals of a
file system is to enable sharing. Furthermore, CertiKOS
is limited to proving security with deterministic specifications. Nondeterminism is important in a file system
to handle crashes and to abstract away implementation
details in specifications.

Ironclad proves that several applications, such as a notary service and a password-hashing application, do not
disclose their own secrets (e.g., a private key), formulated as noninterference. Also using noninterference, Komodo [17] reasons about confidential data in an enclave
and showing that an adversary cannot learn the confidential data. Ironclad and Komodo’s approach cannot specify
or prove a file system: both systems have no notion of a
calling principal or support for multiple users and there
is no possibility of returning confidential data to some
principals (but not others). Finally, there is no support for
nondeterministic crashes.

DiskSec supports nondeterministic crashes, discretionary access control and shared data structures. However it lacks support for branching on confidential data (e.g. hash based logging), abstraction layers and provides weaker guarantees for crashes. It also constrains the developer to a certain proof strategy (i.e. sealed blocks and unsealing traces) to prove noninterference.

%rewrite this
\paragraph{Information flow and type systems.} 
Another approach ensuring confidentiality is to rely on type systems. 

Type systems and static-analysis algorithms, as with
Jif’s labels [27, 28] or the UrFlow analysis [14], have been
developed to reason about information-flow properties of
application code. However, these analyzers are static and
would be hard to use for reasoning about data structures
inside of a file system (such as a write-ahead log or a
buffer cache) that contain data from different users.

%write this
\paragraph{Compositional Noninterference.} 
	%https://www.google.com/books/edition/Principles_of_Security_and_Trust/yKlVDwAAQBAJ?hl=en&gbpv=1&dq=noninterference+composition&pg=PA53&printsec=frontcover
	
	%https://arxiv.org/abs/1910.00905
	
	%https://library.oapen.org/bitstream/handle/20.500.12657/27744/1002261.pdf?sequence=1#page=65
	
	%https://ieeexplore.ieee.org/abstract/document/8029662?casa_token=dQhnCKWA07UAAAAA:AEf00GwLFCEQH78YmZVLyT0ny1-DSYr6g4ibsJiq83pLMpBms7xetLCBh81G9oa0B3_4-y4
	
	%https://publications.cispa.saarland/3213/1/InfoFlowRefinement.pdf
