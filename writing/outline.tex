\documentclass[onecolumn]{paper}
\usepackage{tabularx}
\newcolumntype{L}{>{\raggedright\arraybackslash}X}

\title{ConFrm: Confidentiality Framework for Crash Safe Storage Systems}
\author{Atalay Mert Ileri \and Frans Kaashoek \and Nickolai Zeldovich}
\begin{document}
\maketitle

\section{Abstract}

\section{Introduction}

\section{Related Work}

\section {Definitions}

\section{Confidentiality}
	\subsection{Description and Definitions}

\section{Problems}
        \subsection{Leakage via hashing}

%{\color{red}
% Motivate this problem.
% Maybe refer to DiskSec couldn't do it.
% Protection from adverserial implementation.
% Important point of view.
% Make security similar to FC.
%}

	\paragraph*{Malicious Example}
	\begin{verbatim}
		hash <- hash_block b
		if (hash =/= 0) then
			write given_addr b
		else
			write malicious_addr b
	\end{verbatim}

	\paragraph*{Okay example}
	\begin{verbatim}
		hash <- hash_block b
		if (hash =/= 0) then
			write given_addr b
	\end{verbatim}

	A primitive can be used maliciously.\\
	There isn’t a way to limit how it’s used.\\
	Language level safety techniques are not usable if potentially exploitable primitives are in the language.

	\subsection{Leakage via nondeterminism frequencies}	
	Standard nondeterministic noninterference definition allows leakage via relative frequency of outcomes.
	\paragraph{Nondeterministic Noninterference:}
	
	\begin{verbatim}
		forall p s1 s2 s1’ v,
		R s1 s2 ->
		exec s1 p s1’ v ->
		
		exists s2’,
		exec s2 p s2’ v /\
		R s1’ s2’.
	\end{verbatim} 
	
	
	
	\paragraph*{Leaky example}
	\begin{verbatim}
		should_leak <- get_random_bit()
		if (should_leak = 1)
			return secret_bit
		else
			return get_random_bit()
	\end{verbatim}
	
	This code leaks the secret bit 50\% of the time and outputs a random bit 50\% of the time.
	Satisfies above definition but the secret bit can be determined via the observed frequency.
	
	\begin{tabular}{| c | c | c |}
		\hline
		Secret bit & Output 0 \% & Output 1 \% \\
		\hline
		0 &	75\% & 25\% \\
		\hline
		1 &	25\% & 75\% \\
		\hline
		\end{tabular}
	
	\subsection{Modularity}
        \newpage

\section{ConFrm Framework}
	\subsection{Addressing hash leakage}
	Need to have a way to take advantage of the fact that they are used safely.
	Our solution is abstracting the leaky primitive away.
	Abstract language won’t have a leaky primitive anymore so language level techniques can be used.
	
		\subsubsection{Layer system}
		\subsubsection{Abstraction and Bisimulation}

	\subsection{Addressing frequency leakage}
	Our suggested solution, parameterize the execution with a nondeterminism oracle, so that execution is deterministic w.r.t. an oracle.
		
		\subsubsection{Externalizing the nondeterminism via oracles}
			%%Add an example here to show the difference between old and new semantics
			\paragraph{Deterministic w.r.t. an oracle:}
			\begin{verbatim}
				forall oracle p s s1 v1 s2 v2,
				exec oracle s p s1 v1 ->
				exec oracle s p s2 v2 ->
				s1  = s2 /\ v1 = v2.
			\end{verbatim}
	
			\paragraph{Relativized Noninterference:}
			\begin{verbatim}
				forall oracle p s1 s2 s1’ v,
				R s1 s2 ->
				exec oracle s1 p s1’ v ->
				
				exists s2’,
				exec oracle s2 p s2’ v /\
				R s1’ s2’.
			\end{verbatim}
						
			The malicious example doesn’t satisfy relativized noninterference. For the oracle [should\_leak = 1], there is no corresponding execution from the opposite secret bit value.
			
			\subsubsection{Data Noninterference}
			
			Our definition should cover both leaking from others to current user and from current user to ours. So two components are\\
			
			1)FS doesn't leak from current user's files to others' files.
			
			2)FS doesn't leak from others' files to current user's files.\\
			
			
			(1) can be established with:
			
			- Start with two states where others' files are the same but current user's files are different.
			
			- Run same syscall with same parameters on both.\\ 
			(also two Write/Extend syscalls with different block contents 
			e.g. "Write inum offset block1" vs. "Write inum offset block2")
			
			- Others' files are the same after syscall finishes (or crashes and recovers).\\
			
			(2) can be established with:
			
			- Start with two states where others' files are different but current user's files are the same.
			
			- Run same syscall with same parameters on both
			
			- Current user's files and syscall return values are the same after syscall finishes (or crashes and recovers).\\
			
			For change\_owner, our NI statement (1) will exclude the file that is being operated on. 
			Absence of leakage into the operated file will be covered by functional correctness of change\_owner.
			(i.e. It will state that contents of the file is the same before and after change\_owner)\\
			
			
			{\bf Equivalence Relation}
			
			To cover all of the above, our equivalence relation between two file disks will be parameterized by a user and an option inum.
			It will informally state that:\\
			
			For a user u, a potentially excluded file ex, two file disks d1 and d2, 
			d1 and d2 are equivalent if
			
			1) d1 and d2 have same file handles (i.e. used inums are the same), and\\
			
			$\forall\ inum,\ d1[inum] \ne None \leftrightarrow d2[inum] \ne None$\\
			
			
			2) For any file in d1, corresponding file in d2 have the same owner and the same length. More formally:\\
			
			$\forall\ handle\ inum,$
			
			$d1[inum].owner = d2[inum].owner\ \wedge$
			 
			$length (d1[inum].blocks) = length (d2[inum].blocks)$\\
			
			3)  Any non-excluded file that is owned by u is the same in both disks. \\ 
			
			$\forall\ handle\ inum,$
			 
			$inum \ne ex \rightarrow$
			
			$d1[inum].owner = u \rightarrow$
			
			$d1[inum] = d2[inum]$\\
			
			
			{\bf Semi-Formal Noninterference Definitions}
			
			{\bf Case 1}\\
			
			{\bf Non-change\_owner syscalls}

			$\forall\ d_1\ d_2\ u\ u'\ syscall\ d_1'\ v_1,$
			
			$u \ne u' \rightarrow$
			
			$eqv\ u'\ None\ d_1\ d_2 \rightarrow$
			
			$exec\ u\ d_1\ syscall\ (d_1', v_1) \rightarrow$
			
			$\exists\ d_2'\ v_2,$
			
			$exec\ u\ d_2\ syscall\ (d_2', v_2)\ \wedge$
			
			$eqv\ u'\ None\ d_1'\ d_2'$\\
			
			
			{\bf change\_owner special case}
			
			$\forall\ d_1\ d_2\ u\ u'\ inum\ new\_owner\ d_1'\ v_1,$
			
			$eqv\ u'\ (Some\ inum)\ d_1\ d_2 \rightarrow$
			
			$exec\ u\ d_1\ (change\_owner\ inum\ new\_owner)\ (d_1', v_1) \rightarrow$
			
			$\exists\ d_2'\ v_2,$
			
			$exec\ u\ d_2\ (change\_owner\ inum\ new\_owner)\ (d_2', v_2)\ \wedge$
			
			$eqv\ u'\ (Some\ inum)\ d_1'\ d_2'$\\
			
			
			{\bf Write/Extend special case}
			
			$\forall\ d_1\ d_2\ u\ u'\ inum\ off\ b_1\ b_2\ d_1'\ v_1,$
			
			$eqv\ u'\ (Some\ inum)\ d_1\ d_2 \rightarrow$
			
			$exec\ u\ d_1\ (Write\ inum\ off\ b_1)\ (d_1', v_1) \rightarrow$
			
			$\exists\ d_2'\ v_2,$
			
			$exec\ u\ d_2\ (Write\ inum\ off\ b_2)\ (d_2', v_2)\ \wedge$
			
			$eqv\ u'\ (Some\ inum)\ d_1'\ d_2'$\\
			
			{\bf Case 2}
			 
			 $\forall\ d_1\ d_2\ u\ syscall\ d_1'\ v_1,$
			 
			 $eqv\ u\ None\ d_1\ d_2 \rightarrow$
			 
			 $exec\ u\ d_1\ syscall\ (d_1', v_1) \rightarrow$
			 
			 $\exists\ d_2'\ v_2,$
			 
			 $exec\ u\ d_2\ syscall\ (d_2', v_2)\ \wedge$
			 
			 $eqv\ u\ None\ d_1'\ d_2'\ \wedge$
			 
			 $v_1 = v_2$\\
			
			
			{\bf Functional correctness for change\_owner}\\
			forall d1 u inum new\_owner d1',
			exec u d1 (change\_owner inum new\_owner) (d1', Some tt) ->
			d1'[inum] = {| owner:= new\_owner; blocks:=d1[inum].blocks |}.\\
			
			
			
			{\bf Merging into a single NI statement}
			Since (1) and (2) are very similar, we can merge both of them into a single definition that captures both:\\
			
			$\forall\ d_1\ d_2\ u\ u'\ syscall\ d_1'\ v_1,$
			
			$eqv\ u'\ None\ d_1\ d_2 \rightarrow$
			
			$exec\ u\ d_1\ syscall\ (d_1', v_1) \rightarrow$
			
			$\exists\ d_2'\ v_2,$
			
			$exec\ u\ d_2\ syscall\ (d_2', v_2)\ \wedge$
			
			$eqv\ u'\ None\ d_1'\ d_2'\ \wedge$
			
			$(u = u' \rightarrow v_1 = v_2)$\\
			
			{\bf Why do we need special change\_owner definition?}
			In general definition, if u' = new\_owner, contents of the file we are operating on may not be identical in equivalent states. 
			Because of this, resulting states may not be equivalent for the new owner. 
			This fact requires us to use a sligthly weaker variant of the equivalence for change\_owner.
			
			Weaker variant does not state anything about the contents of the operated file.
			Proof of contents not changing comes from the functional correctness.\\
			
			
			{\bf Why do we need special Write/Extend definitions?}\\
			Here is an implementation of extend syscall that satisfies the generic definition but leaks the data in a future call.
			
			\begin{verbatim}
				extend (inum, block){
					append_to_file(stash_file, block)
					append_to_file(inum, block)
				}
			\end{verbatim}
			
			
			if two states were equivalent before, they will be still equivalent after if  you extend with the same block. Coupled with an adversarial Read implementation, this can cause leakage of private data although satisfying the generic definition.
			
			However, this implementation will not satisfy the special case theorem because different values will break equivalence between stash files.\\
			
			{\bf What if an implementation uses a hidden underlying layer primitive (like a stash block that is not part of any file) to stash data?}\\
			
			In that case, two implementation states that differ only in stash block will refine to the same abstract state (which is equivalent to itself for every user). 
			
			If that is the case, then a read implementation that would return stash\_block's content would return two different values from the same state. This would prevent both NI and Simulation obligations to be proven correct.\\
			
			{\bf TLDR}\\
			We need to prove following 3 NI statements and one FC statement:
			
			For all syscalls except change\_owner,
			
			forall d1 d2 u u' syscall d1' v1,
			eqv u' None d1 d2 ->
			exec u d1 syscall (d1', v1) ->
			exists d2' v2,
			exec u d2 syscall (d2', v2) /\
			eqv u' None d1' d2' /\
			(u = u' -> v1 = v2).
			
			For Write (and Extend) special case:
			
			// Document reason why it is this way
			// Create examples
			// Think if it needs to be general or simplified
			
			forall d1 d2 u u' inum off b1 b2 d1' v1,
			eqv u' (Some inum) d1 d2 ->
			exec u d1 (Write inum off b1) (d1', v1) ->
			exists d2' v2,
			exec u d2 (Write inum off b2) (d2', v2) /\
			eqv u' (Some inum) d1' d2'.
			
			
			
			Do we need generality?
			?????
			
			For change\_owner:
			
			forall d1 d2 u u' inum new\_owner d1' v1,
			eqv u' (Some inum) d1 d2 ->
			exec u d1 (change\_owner inum new\_owner) (d1', v1) ->
			exists d2' v2,
			exec u d2 (change\_owner inum new\_owner) (d2', v2) /\
			eqv u' (Some inum) d1' d2' /\
			(u = u' -> v1 = v2).	
			
			
			
			
			Functional Correctness:
			forall d1 u inum new\_owner d1',
			exec u d1 (change\_owner inum new\_owner) (d1', Some tt) ->
			d1'[inum] = {| owner:= new\_owner; blocks:=d1[inum].blocks |}.
			
			
			
		\subsubsection{Generalizing simulations to oracles}

	\subsection{Compositionality}
		\subsubsection{Layer system}
		\subsubsection{Noninterference transfer}
		\subsubsection{Bisimulation to Simulation via Determinism}

	\subsection{Crash Support}
		\subsubsection{Crash semantics} 
		\subsubsection{Reboot functions}
		\subsubsection{Crash refinement}
\newpage
\section{Framework in Action: ConFS}
	\subsection{Design and Specs}
		\subsubsection{Layers}
			\begin{tabularx}{\linewidth}{|L|L|L|L|}
				\hline
				Layer Name &
				Operations &
				State &
				Type \\
				\hline
				Disk &
				Read, Write, Sync &
				A $\rightarrow$ (V * list V) &
				Basic \\
				\hline
				Cache &
				Read, Write, Flush &
				A $\rightarrow$ option V &
				Basic \\
				\hline
				Crypto &
				Hash, GetKey, Encrypt, Decrypt &
				list key, 
				hash $\rightarrow$ option (hash, V) &
				Basic \\
				\hline
				Crypto Disk &
				Crypto ops + Disk ops &
				Crypto state + Disk state &
				Composed \\
				\hline
				Cached Disk &
				Cache ops + Crypto Disk ops &
				Cache state + Crypto Disk state &
				Composed \\
				\hline
				Logged Disk &
				Read, Write, Recover &
				A $\rightarrow$ V &
				Abstraction \\ 
				\hline
				Storage &
				Get, Put, Delete &
				option V &
				Basic \\
				\hline
				Transaction Cache &
				Storage ops + Logged Disk ops &
				Storage state + Logged Disk state &
				Composed \\
				\hline
				Transactional Disk &
				Start, Read, Write, Commit, Abort, Recover &
				mem A V , mem A V &
				Abstraction \\
				\hline
				Authentication &
				Auth &
				user &
				Basic \\
				\hline
				Authenticated Disk &
				Authentication ops + Transactional Disk ops &
				Authentication state + Transactional Disk state &
				Composed \\
				\hline
				File Disk &
				Read, Write, Extend, Set Owner, Create, Delete, Recover &
				mem A File &
				Abstraction \\
				\hline
			\end{tabularx}
	\subsection{Implementation}
		\subsubsection{Modules}
		\subsubsection{Hash collisions and encrypted log}
\newpage
\section{Evaluation}
        \subsection{Are specs reasonable?}
	\subsection{Did we achieve the goal?}
	\subsection{How much work did it take?}
	\subsection{What is the performance of the file system?}

\section{Conclusion}

\end{document}
